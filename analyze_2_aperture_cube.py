#!/usr/bin/env python

import sys
import scipy.ndimage as nd
import numpy as np
import pyfits
from matplotlib.pyplot import acorr as acorr
from matplotlib.mlab import detrend_linear as detrend_linear

"""
Define a function to read a FITS image and return the data it contains. The
use of the `memmap=True` argument here is important because the data cubes
generated by the seeing camera are >700 MB in size and can be even larger. It
would be inefficient to load the entire dataset into memory if we're not going
to use it all.
"""

def rfits(file):
    f = pyfits.open(file, memmap=True)
    return f[0].data

"""
Define a function to find spots within an image. This method smooths the image
with a gaussian of width `sigma` and then clips the image by `clip_level` above
the mean. The clipped image is passed to `scipy.ndimage.label` to find regions
of associated flux, i.e. the spots we're looking for. These labels are used in
`scipy.ndimage.center_of_mass` to calculate centroids of the flux within
labeled regions.
"""

def spotfind(im, sigma=1.1, clip_level=6.0):
    mean = np.mean(im)
    sig = np.std(im)
    smooth = nd.gaussian_filter(im, sigma)
    clip = smooth >= (mean + clip_level)
    labels, num = nd.label(clip)
    pos = nd.center_of_mass(im, labels, range(num + 1))
    return num, pos[1:]

"""
Load in an image cube and display the first image. Python uses row-first
indexing so the cube indexing goes as `cube[z, y, x]`.
"""

filename = sys.argv[1]
cube = rfits(filename)

"""
Take an image from the middle of the cube, find the spots in it, and use the
positions to set up the region of interest to analyze for the rest of the cube.
"""

slice = 5000
num, spots = spotfind(cube[slice, :, :], sigma=1.0, clip_level=1.0)
print "Found %d spots." % num
spots = np.array(spots, dtype=[('y', float), ('x', float)])
xcen = spots['x'].mean()
ycen = spots['y'].mean()
xmin = int(xcen - 40)
xmax = int(xcen + 40)
ymin = int(ycen - 40)
ymax = int(ycen + 40)

"""
Now loop through the whole cube and run `spotfind()` on each image. Check to
make sure there are 2 valid spots, sort the resulting spot positions in order
of their X position, and appends the results to an array called `spots`. Notice
the use of `x` and `y` labels when defining the `numpy.array` that contains the
spots for an image. This labeling simplifies how we refer to the data later on.
At the end, convert `spots` to a `numpy.array` for further analysis.
"""

spots = []
nfailed = 0
for im in cube[:, ymin:ymax, xmin:xmax]:
    n, s = spotfind(im, sigma=1.0, clip_level=0.5)
    if n == 2:
        ss = np.array(s, dtype=[('y', float), ('x', float)])
        ss.sort(order='x')
        spots.append(ss)
    else:
        nfailed += 1
print "Failed to find right number of spots in %d images." % nfailed
SS = np.array(spots, dtype=[('y', float), ('x', float)])

"""
Define a function to measure the distance between two spots for all
measurements of those spots. It takes as arguments the array containing the
spot centroids and the desired spot indicies.
"""

def spotdist(spots, spot1, spot2):
    return np.hypot(spots['x'][:, spot1] - spots['x'][:, spot2],
                    spots['y'][:, spot1] - spots['y'][:, spot2])

"""
Measure the distance between the two spots and calculate its standard
deviation
"""
baseline01 = spotdist(SS, 0, 1)
rms = baseline01.std()

"""
To convert the variance in the spot distance to a measure of the turbulence,
we need to know some properties of the DIMM system and use a model for the
turbulence.
"""

# this is the pixel scale of the DIMM detector in "/pixel as measured using
# known double stars
pixel_scale = 1.046

# this is the diameter of an aperture in meters for the Astelco mask
d = 0.0735

# this is the distance between the apertures. 
r = 0.19

# this routine uses tokovinin's modified equation given in 2002, PASP, 114, 1156
def seeing(rms, r, d, scale):
    b = r/d
    l = 0.6e-6
    var = (rms * scale / 206265.0)**2
    K = 0.364 * (1.0 - 0.532 * b**(-1.0/3.0) - 0.024 * b**(-7.0/3.0))
    fwhm = 206265.0 * 0.98 * (d/l)**0.2 * (var/K)**0.6
    return fwhm

# this is the raw seeing with no correction for airmass
seeing01 = seeing(rms, r, d, pixel_scale)
print "Raw seeing value for %s: %.3f\"" % (filename, seeing01)

"""
It's useful to look at the autocorrelation of the spot motion. The DIMM method
assumes that the motions are completely uncorrelated and any significant
correlation can lead to biased results.
"""

# measure the autocorrelation for spots 0 and 1
a01 = acorr(baseline01, normed=True, detrend=detrend_linear, usevlines=True, maxlags=50)
ac = a01[1]

# take the correlation time to be when the coefficient is half of the peak
# value.  convert to ms using the default frame rate of 3 ms/frame
ctime = 3.0 * len(ac[ac > 0.5])/2.0
print "Correlation time: %.3f ms" % ctime

